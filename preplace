#!/usr/bin/env python
#
# Copyright (C) 2008 Rico Schiekel (fire at downgra dot de)
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
# vim:syntax=python:sw=4:ts=4:expandtab

import os
import re
import types
import fnmatch
import itertools
import fileinput
import difflib
from optparse import OptionParser

def no(seq, pred=None):
    """Returns True if pred(x) is false for every element in the iterable"""
    for elem in itertools.ifilter(pred, seq):
        return False
    return True

def msg(s):
    """print message if not quiet"""
    if not options.quiet:
        print s

def filter_names(names, filters = None):
    """filter list of names using provided filters"""
    if not filters:
        filters = []

    def match(name):
        m = False
        # includes
        for pattern in [p for p in file_patterns + filters if not p.startswith('~')]:
            if fnmatch.fnmatch(name, pattern):
                m = True
                break
        if m:
            # excludes
            for pattern in [p[1:] for p in file_patterns + filters if p.startswith('~')]:
                if fnmatch.fnmatch(name, pattern):
                    m = False
                    break
        return m

    for n in names:
        if match(n):
            yield n

def file_replace(file):
    try:
        args = {}
        if options.backup:
            args['backup'] = options.backup_suffix
        for line in fileinput.input(file, inplace = 1, **args):
            print re.sub(SR, RR, line),
    except IOError, e:
        msg(e)

def file_diff(file):
    changed = False
    try:
        f = open(file, 'r')
        try:
            lines = f.readlines()
        finally:
            f.close()

        for line in difflib.unified_diff(lines, [re.sub(SR, RR, l) for l in lines], file, file + '.new'):
            print line,
            changed = True
    except IOError, e:
        msg(e)
    return changed

def dir_visitor(root, dirs, files):
    files = [os.path.join(root, f) for f in filter_names(files)]
    if files:
        for fn in files:
            if options.verbose:
                if file_diff(fn):
                    print
            else:
                msg('processing %s' % fn)
            if not options.dry_run:
                file_replace(fn)
    if not options.recursive:
        del dirs[:]
    else:
        dirs[:] = filter_names(dirs, ['*'])

if __name__ == '__main__':
    parser = OptionParser(usage = 'usage: %prog [options] pattern pattern [files]')

    parser.set_defaults(backup = False)
    parser.add_option('-b',
                      action = 'store_true',
                      dest = 'backup',
                      help = 'backup files')

    parser.set_defaults(backup_suffix = '.orig')
    parser.add_option('--suffix',
                      dest = 'backup_suffix',
                      type = 'string',
                      metavar = 'S',
                      help = 'backup suffix (default: .orig)')

    parser.set_defaults(recursive = False)
    parser.add_option('-r',
                      action = 'store_true',
                      dest = 'recursive',
                      help = 'recursive')

    parser.set_defaults(directory = '.')
    parser.add_option('-d',
                      dest = 'directory',
                      type = 'string',
                      metavar = 'D',
                      help = 'directory')

    parser.set_defaults(ignore_case = False)
    parser.add_option('-I',
                      action = 'store_true',
                      dest = 'ignore_case',
                      help = 'ignore case')

    parser.set_defaults(multiline = False)
    parser.add_option('-M',
                      action = 'store_true',
                      dest = 'multiline',
                      help = 'multiline')

    parser.set_defaults(quiet = False)
    parser.add_option('-q',
                      action = 'store_true',
                      dest = 'quiet',
                      help = 'quiet')

    parser.set_defaults(verbose = False)
    parser.add_option('-v',
                      action = 'store_true',
                      dest = 'verbose',
                      help = 'verbose (unified diff output)')

    parser.set_defaults(dry_run = False)
    parser.add_option('-n', '--dry-run',
                      action = 'store_true',
                      dest = 'dry_run',
                      help = 'dry_run')

    (options, args) = parser.parse_args()

    if len(args) < 2:
        parser.error('you must specify the search/replace patterns!')

    file_patterns = args[2:]
    if not file_patterns or no(file_patterns, lambda x: not x.startswith('~')):
        file_patterns.insert(0, '*')

    config_file = os.path.expanduser('~/.preplacerc')
    if os.path.isfile(config_file):
        g = {}
        l = {}
        execfile(config_file, g, l)
        includes = l.get('INCLUDES', [])
        excludes = l.get('EXCLUDES', [])
        if not isinstance(includes, (types.ListType, types.TupleType)):
            includes = [includes]
        if not isinstance(excludes, (types.ListType, types.TupleType)):
            excludes = [excludes]
        file_patterns.extend(includes)
        file_patterns.extend([e for e in excludes if e.startswith('~')])
        file_patterns.extend(['~' + e for e in excludes if not e.startswith('~')])

    re_flags = []
    if options.ignore_case:
        re_flags.append(re.I)
    if options.multiline:
        re_flags.append(re.M)

    SR = re.compile(args[0], *re_flags)
    RR = args[1]

    try:
        for root, dirs, files in os.walk(options.directory):
            dir_visitor(root, dirs, files)
    except KeyboardInterrupt:
        print 'Abort...'
