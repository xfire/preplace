#!/usr/bin/env python
#
# vim:syntax=python:sw=4:ts=4:expandtab

# preplace [options] r1 r2 [files]
# e.g.
#   preplace -I '^include (?P<foo>.*)$' 'import \g<foo>' '*.cc'
#
# options:
#   -b          backup files
#   --suffix    backup suffix (default: ???)
#   -r          recursive
#   -d          directory
#   -I          ignore case
#   -M          multiline

import os
import re
import fnmatch
import itertools
from optparse import OptionParser


parser = OptionParser(usage = 'usage: %prog [options] pattern pattern [files]')

parser.set_defaults(backup = False)
parser.add_option('-b',
                  action = 'store_true',
                  dest = 'backup',
                  help = 'backup files')

parser.set_defaults(backup_suffix = '.orig')
parser.add_option('--suffix',
                  dest = 'backup_suffix',
                  type = 'string',
                  metavar = 'S',
                  help = 'backup suffix (default: .orig)')

parser.set_defaults(recursive = False)
parser.add_option('-r',
                  action = 'store_true',
                  dest = 'recursive',
                  help = 'recursive')

parser.set_defaults(directory = '.')
parser.add_option('-d',
                  dest = 'directory',
                  type = 'string',
                  metavar = 'D',
                  help = 'directory')

parser.set_defaults(ignore_case = False)
parser.add_option('-I',
                  action = 'store_true',
                  dest = 'ignore_case',
                  help = 'ignore case')

parser.set_defaults(multiline = False)
parser.add_option('-M',
                  action = 'store_true',
                  dest = 'multiline',
                  help = 'multiline')

parser.set_defaults(quiet = False)
parser.add_option('-q',
                  action = 'store_true',
                  dest = 'quiet',
                  help = 'quiet')

(options, args) = parser.parse_args()

if len(args) < 2:
    parser.error('you must specify the search/replace patterns!')

print options, args

def no(seq, pred=None):
    """Returns True if pred(x) is false for every element in the iterable"""
    for elem in itertools.ifilter(pred, seq):
        return False
    return True

file_patterns = args[2:]
if not file_patterns or no(file_patterns, lambda x: not x.startswith('~')):
    file_patterns.insert(0, '*')

def msg(s):
    """print message if not quiet"""
    if not options.quiet:
        print s

def filter(names):
    """filter list of names using provided filters"""
    def match(name):
        m = False
        # includes
        for pattern in [p for p in file_patterns if not p.startswith('~')]:
            if fnmatch.fnmatch(name, pattern):
                m = True
                break
        if m:
            # excludes
            for pattern in [p[1:] for p in file_patterns if p.startswith('~')]:
                if fnmatch.fnmatch(name, pattern):
                    m = False
                    break
        return m
    l = []
    for n in names:
        if match(n):
            l.append(n)
    return l

def visitor(root, dirs, files):
    files = filter(files)
    if files:
        for fn in files:
            msg('  %s' % os.path.join(root, fn))
    if not options.recursive:
        del dirs[:]

for root, dirs, files in os.walk(options.directory):
    visitor(root, dirs, files)

