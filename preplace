#!/usr/bin/env python
#
# Copyright (C) 2008 Rico Schiekel (fire at downgra dot de)
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
# vim:syntax=python:sw=4:ts=4:expandtab

import sys
import os
import re
import types
import fnmatch
import itertools
import fileinput
import difflib
from optparse import OptionParser

def no(seq, pred=None):
    """Returns True if pred(x) is false for every element in the iterable"""
    for elem in itertools.ifilter(pred, seq):
        return False
    return True

def msg(s):
    """print message if not quiet"""
    if not options.quiet:
        print s

def filter_names(names, filters = None):
    """filter list of names using provided filters"""
    if not filters:
        filters = []

    def match(name):
        m = False
        # includes
        for pattern in [p for p in file_patterns + filters if not p.startswith('~')]:
            if fnmatch.fnmatch(name, pattern):
                m = True
                break
        if m:
            # excludes
            for pattern in [p[1:] for p in file_patterns + filters if p.startswith('~')]:
                if fnmatch.fnmatch(name, pattern):
                    m = False
                    break
        return m

    for n in names:
        if match(n):
            yield n

def file_replace(file):
    try:
        args = {}
        if options.backup:
            args['backup'] = options.backup_suffix
        for line in fileinput.input(file, inplace = 1, **args):
            print re.sub(SR, RR, line),
    except IOError, e:
        msg(e)

def file_diff(file):
    changed = False
    try:
        f = open(file, 'r')
        try:
            lines = f.readlines()
        finally:
            f.close()

        for line in difflib.unified_diff(lines, [re.sub(SR, RR, l) for l in lines], file, file + '.new'):
            print line,
            changed = True
    except IOError, e:
        msg(e)
    return changed

def dir_visitor(root, dirs, files):
    files = [os.path.join(root, f) for f in filter_names(files)]
    if files:
        for fn in files:
            if options.verbose:
                if file_diff(fn):
                    print
            else:
                msg('processing %s' % fn)
            if not options.dry_run:
                file_replace(fn)
    if not options.recursive:
        del dirs[:]
    else:
        dirs[:] = filter_names(dirs, ['*'])

def parse_arguments():
    parser = OptionParser(usage = 'usage: %prog [options] pattern pattern [files]')

    parser.set_defaults(backup = False)
    parser.add_option('-b',
                      action = 'store_true',
                      dest = 'backup',
                      help = 'backup files')

    parser.set_defaults(backup_suffix = '.orig')
    parser.add_option('--suffix',
                      dest = 'backup_suffix',
                      type = 'string',
                      metavar = 'S',
                      help = 'backup suffix (default: .orig)')

    parser.set_defaults(recursive = False)
    parser.add_option('-r',
                      action = 'store_true',
                      dest = 'recursive',
                      help = 'recursive')

    parser.set_defaults(directory = '.')
    parser.add_option('-d',
                      dest = 'directory',
                      type = 'string',
                      metavar = 'D',
                      help = 'directory')

    parser.set_defaults(ignore_case = False)
    parser.add_option('-I',
                      action = 'store_true',
                      dest = 'ignore_case',
                      help = 'ignore case')

    parser.set_defaults(multiline = False)
    parser.add_option('-M',
                      action = 'store_true',
                      dest = 'multiline',
                      help = 'multiline')

    parser.set_defaults(quiet = False)
    parser.add_option('-q',
                      action = 'store_true',
                      dest = 'quiet',
                      help = 'quiet')

    parser.set_defaults(verbose = False)
    parser.add_option('-v',
                      action = 'store_true',
                      dest = 'verbose',
                      help = 'verbose (unified diff output)')

    parser.set_defaults(dry_run = False)
    parser.add_option('-n', '--dry-run',
                      action = 'store_true',
                      dest = 'dry_run',
                      help = 'dry_run')

    parser.set_defaults(config_file = '~/.preplacerc')
    parser.add_option('--config',
                      dest = 'config_file',
                      type = 'string',
                      metavar = 'C',
                      help = 'configuration file (default: ~/.preplacerc)')

    (options, args) = parser.parse_args()

    if len(args) < 2:
        parser.error('you must specify the search/replace patterns!')

    file_patterns = args[2:]
    includes = set([p for p in file_patterns if not p.startswith('~')])
    excludes = set([p[1:] for p in file_patterns if p.startswith('~')])

    config_file = os.path.expanduser(options.config_file)
    if os.path.isfile(config_file):
        g = {}
        l = {}
        try:
            execfile(config_file, g, l)
        except Exception, e:
            print 'error, invalid configuration file (%s): %s' % (config_file, e)
            sys.exit(1)
        cfi = l.get('INCLUDES', [])
        cfe = l.get('EXCLUDES', [])
        if not isinstance(cfi, (types.ListType, types.TupleType)):
            cfi = [cfi]
        if not isinstance(cfe, (types.ListType, types.TupleType)):
            cfe = [cfe]
        includes.update(cfi)
        excludes.update(cfe)

    if not includes:
        includes.add('*')

    re_flags = []
    if options.ignore_case:
        re_flags.append(re.I)
    if options.multiline:
        re_flags.append(re.M)

    regex_old = re.compile(args[0], *re_flags)
    regex_new = args[1]

    return (regex_old, regex_new, includes, excludes, options)

if __name__ == '__main__':
    regex_old, regex_new, includes, excludes, options = parse_arguments()
    print includes
    print excludes

    # try:
    #     for root, dirs, files in os.walk(options.directory):
    #         dir_visitor(root, dirs, files)
    # except KeyboardInterrupt:
    #     print 'Abort...'
