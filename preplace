#!/usr/bin/env python
#
# vim:syntax=python:sw=4:ts=4:expandtab

# preplace [options] r1 r2 [files]
# e.g.
#   preplace -I '^include (?P<foo>.*)$' 'import \g<foo>' '*.cc'
#
# options:
#   -b          backup files
#   --suffix    backup suffix (default: ???)
#   -r          recursive
#   -d          directory
#   -I          ignore case
#   -M          multiline
#   -q          quiet
#   -n          dry run
#   --dry-run   

import os
import re
import fnmatch
import itertools
import fileinput
from optparse import OptionParser

def no(seq, pred=None):
    """Returns True if pred(x) is false for every element in the iterable"""
    for elem in itertools.ifilter(pred, seq):
        return False
    return True

def msg(s):
    """print message if not quiet"""
    if not options.quiet:
        print s

def filter(names):
    """filter list of names using provided filters"""
    def match(name):
        m = False
        # includes
        for pattern in [p for p in file_patterns if not p.startswith('~')]:
            if fnmatch.fnmatch(name, pattern):
                m = True
                break
        if m:
            # excludes
            for pattern in [p[1:] for p in file_patterns if p.startswith('~')]:
                if fnmatch.fnmatch(name, pattern):
                    m = False
                    break
        return m
    l = []
    for n in names:
        if match(n):
            l.append(n)
    return l

def replace(file):
    try:
        args = {}
        if options.backup:
            args['backup'] = options.backup_suffix
        for line in fileinput.input(file, inplace = 1, **args):
            print re.sub(SR, RR, line)
    except IOError, e:
        msg(e)

def dir_visitor(root, dirs, files):
    files = filter([os.path.join(root, f) for f in files])
    if files:
        for fn in files:
            msg('%s' % fn)
            if not options.dry_run:
                replace(fn)
    if not options.recursive:
        del dirs[:]
    ndirs = filter(dirs)
    dirs[:] = ndirs


if __name__ == '__main__':
    parser = OptionParser(usage = 'usage: %prog [options] pattern pattern [files]')

    parser.set_defaults(backup = False)
    parser.add_option('-b',
                      action = 'store_true',
                      dest = 'backup',
                      help = 'backup files')

    parser.set_defaults(backup_suffix = '.orig')
    parser.add_option('--suffix',
                      dest = 'backup_suffix',
                      type = 'string',
                      metavar = 'S',
                      help = 'backup suffix (default: .orig)')

    parser.set_defaults(recursive = False)
    parser.add_option('-r',
                      action = 'store_true',
                      dest = 'recursive',
                      help = 'recursive')

    parser.set_defaults(directory = '.')
    parser.add_option('-d',
                      dest = 'directory',
                      type = 'string',
                      metavar = 'D',
                      help = 'directory')

    parser.set_defaults(ignore_case = False)
    parser.add_option('-I',
                      action = 'store_true',
                      dest = 'ignore_case',
                      help = 'ignore case')

    parser.set_defaults(multiline = False)
    parser.add_option('-M',
                      action = 'store_true',
                      dest = 'multiline',
                      help = 'multiline')

    parser.set_defaults(quiet = False)
    parser.add_option('-q',
                      action = 'store_true',
                      dest = 'quiet',
                      help = 'quiet')

    parser.set_defaults(dry_run = False)
    parser.add_option('-n', '--dry-run',
                      action = 'store_true',
                      dest = 'dry_run',
                      help = 'dry_run')

    (options, args) = parser.parse_args()

    if len(args) < 2:
        parser.error('you must specify the search/replace patterns!')

    file_patterns = args[2:]
    if not file_patterns or no(file_patterns, lambda x: not x.startswith('~')):
        file_patterns.insert(0, '*')

    SR = re.compile(args[0])
    RR = args[1]

    for root, dirs, files in os.walk(options.directory):
        dir_visitor(root, dirs, files)

